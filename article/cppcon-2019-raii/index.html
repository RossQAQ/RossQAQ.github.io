<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。"><title>RAII and the Rule of Zero</title>
<link rel=canonical href=https://rossqaq.github.io/article/cppcon-2019-raii/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="RAII and the Rule of Zero"><meta property='og:description' content="对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。"><meta property='og:url' content='https://rossqaq.github.io/article/cppcon-2019-raii/'><meta property='og:site_name' content='Roses'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2023-12-23T00:00:00+00:00'><meta property='article:modified_time' content='2023-12-23T00:00:00+00:00'><meta property='og:image' content='https://rossqaq.github.io/article/cppcon-2019-raii/cppcon2019-cover.png'><meta name=twitter:title content="RAII and the Rule of Zero"><meta name=twitter:description content="对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://rossqaq.github.io/article/cppcon-2019-raii/cppcon2019-cover.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu57fe4ea25b3b752b8c24bca0d657f08c_427356_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>♉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Roses</a></h1><h2 class=site-description>有限的时间，无尽的痛苦。</h2></div></header><ol class=menu-social><li><a href=https://space.bilibili.com/3078464 target=_blank title=Bilibili rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-bilibili" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z"/><path d="M8 3l2 3"/><path d="M16 3l-2 3"/><path d="M9 13v-2"/><path d="M15 11v2"/></svg></a></li><li><a href=https://github.com/RossQAQ target=_blank title=Github rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href='https://music.163.com/playlist?id=109571638&amp;userid=93740300' target=_blank title=网易云音乐 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-netease-music" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 4c-2.93 1.346-5 5.046-5 8.492C4 17 8 20 12 20s8-3 8-7c0-3.513-3.5-5.513-6-5.513S9 9 9 12c0 2 1.5 3 3 3s3-1 3-3c0-3.513-2-4.508-2-6.515.0-3.504 3.5-2.603 4-1.502"/></svg></a></li><li><a href=mailto:rossqaq@outlook.com target=_blank title=邮件 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友情链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#资源-resource>资源 Resource</a></li><li><a href=#以-naive-vector-为例>以 naive vector 为例</a><ol><li><a href=#基础实现>基础实现</a></li><li><a href=#析构函数>析构函数</a></li><li><a href=#拷贝构造函数>拷贝构造函数</a></li><li><a href=#初始化不是赋值>初始化不是赋值</a></li><li><a href=#the-rule-of-three>The Rule of Three</a></li></ol></li><li><a href=#raii-与异常安全>RAII 与异常安全</a></li><li><a href=#the-rule-of-zero>The Rule of Zero</a></li><li><a href=#尽可能多选择-rule-of-zero>尽可能多选择 Rule of Zero</a></li><li><a href=#the-rule-of-five>The Rule of Five</a></li><li><a href=#the-rule-of-fourand-a-half>The Rule of Four(and a half)</a><ol><li><a href=#by-value-的赋值运算符>By-value 的赋值运算符？</a></li><li><a href=#the-rule-of-four-and-a-half>The Rule of Four (and a half)</a></li></ol></li><li><a href=#copy-and-swap>copy-and-swap</a></li><li><a href=#不再-naive-的-vector>不再 Naive 的 vector</a></li><li><a href=#管理资源类的例子>管理资源类的例子</a><ol><li><a href=#stdunique_ptr>std::unique_ptr</a></li><li><a href=#stdshared_ptr>std::shared_ptr</a></li></ol></li><li><a href=#盗取暗示了空状态>“盗取”暗示了“空”状态</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/article/cppcon-2019-raii/><img src=/article/cppcon-2019-raii/cppcon2019-cover_hu93d2f8befaf9243db44dc194e94262d5_58262_800x0_resize_box_3.png srcset="/article/cppcon-2019-raii/cppcon2019-cover_hu93d2f8befaf9243db44dc194e94262d5_58262_800x0_resize_box_3.png 800w, /article/cppcon-2019-raii/cppcon2019-cover_hu93d2f8befaf9243db44dc194e94262d5_58262_1600x0_resize_box_3.png 1600w" width=800 height=339 loading=lazy alt="Featured image of post RAII and the Rule of Zero"></a></div><div class=article-details><header class=article-category><a href=/categories/cppcon/ style=background-color:#2a9d8f;color:#fff>CppCon
</a><a href=/categories/finished/ style=background-color:#2a9d8f;color:#fff>施工完毕</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/article/cppcon-2019-raii/>RAII and the Rule of Zero</a></h2><h3 class=article-subtitle>对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 23, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><p><a class=link href="https://www.youtube.com/watch?v=7Qgd9B1KuMQ" target=_blank rel=noopener>Lecture: Back to Basics: RAII and the Rule of Zero - Arthur O&rsquo;Dwyer - CppCon 2019</a></p><p><a class=link href=https://github.com/CppCon/CppCon2019/blob/master/Presentations/back_to_basics_raii_and_the_rule_of_zero/back_to_basics_raii_and_the_rule_of_zero__arthur_odwyer__cppcon_2019.pdf target=_blank rel=noopener>Slides PDF</a></p><p>RAII 即：Resource Acquisition Is Initialization，资源获取即初始化。</p><blockquote><p>不会 RAII 等于不会 C++。 —— Roses</p></blockquote><h2 id=资源-resource>资源 Resource</h2><p>资源代表某些我们需要手动管理的东西。C++ 中常见的资源有：</p><ul><li>分配的内存（malloc/free, new/delete, new[]/delete[]）</li><li>POSIX 文件句柄 （open/close）</li><li>C 文件句柄（fopen/fclose）</li><li>mutex 锁</li><li>C++ 线程</li></ul><p>我们无需关心资源是否唯一（例如mutex 的设计就是唯一的，而分配的内存显然可以拥有拷贝）</p><p>我们需要关心的是<strong>程序中需要 <em>显式</em> 使用某些操作来 <em>释放</em> 资源</strong></p><p>之后会一直使用堆分配的内存作为例子。</p><h2 id=以-naive-vector-为例>以 naive vector 为例</h2><h3 id=基础实现>基础实现</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NaiveVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>ptr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span><span class=p>()</span> <span class=o>:</span> <span class=n>ptr_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>size_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>push_back</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=o>*</span> <span class=n>new_ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>size_</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>copy</span><span class=p>(</span><span class=n>ptr_</span><span class=p>,</span> <span class=n>ptr_</span> <span class=o>+</span> <span class=n>size</span><span class=p>,</span> <span class=n>new_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>ptr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ptr_</span> <span class=o>=</span> <span class=n>new_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ptr_</span><span class=p>[</span><span class=n>size_</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>这里 push_back 先分配内存，再将原来的数据进行拷贝，最后写入新的数据，<strong>释放原来位置的内存</strong>，看起来没有问题。</p><p>考虑以下使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span> <span class=n>vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里，出作用域后，vec 的内存并没有被释放，显然是发生<strong>内存泄漏</strong>了。</p><p>也就是说，<strong>需要在 vector 的生命周期结束时，释放其拥有的内存</strong>。</p><hr><h3 id=析构函数>析构函数</h3><p>众所周知，在创建一个类类型的对象时，编译器会调用某个构造函数；在一个类类型对象的生命周期结束时，编译器会调用<strong>析构函数</strong>。</p><blockquote><p>在 C++ 中，常用的限制某对象生命周期的方法就是使用一个大括号。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span> <span class=n>vec</span><span class=p>;</span>	<span class=c1>// 调用构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>			<span class=c1>// 调用析构函数
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NaiveVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>NaiveVector</span><span class=p>()</span> <span class=p>{</span><span class=k>delete</span><span class=p>[]</span> <span class=n>ptr_</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>现在 NaiveVector 就不会在被销毁时发生内存泄漏了。</p><hr><h3 id=拷贝构造函数>拷贝构造函数</h3><p>考虑代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>NaiveVector</span> <span class=n>w</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>	<span class=c1>//(1)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在 (1) 处调用了编译器自动生成的拷贝构造函数，默认的拷贝构造函数只是单纯的拷贝每个成员，这会导致二者持有指向同一块内存的指针，w 析构时内存会被释放，此时 v 访问的是已经被释放的内存。</p><blockquote><p>(1) 处的操作某些语言称之为“浅拷贝”。</p><p>需要注意的是，C++ 的设计哲学使得类对象应该具有值语义（标准库组件也是这么做的）。</p><p>换句话说，对对象进行拷贝应该像拷贝 <code>int</code> 等类型一样，进行“深拷贝”而不是所谓“浅拷贝”。</p><p>我其实并不想用在 C++ 中用这两个词语来描述，只是这样更容易理解。</p></blockquote><p>这也是为什么 C++ 提供了拷贝构造函数的原因。<strong>你需要他来为资源创建副本</strong>。</p><p>我们来实现他：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NaiveVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span><span class=p>()</span> <span class=o>:</span> <span class=n>ptr_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>size_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>NaiveVector</span><span class=p>()</span> <span class=p>{</span><span class=k>delete</span><span class=p>[]</span> <span class=n>ptr_</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span><span class=p>(</span><span class=k>const</span> <span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ptr_</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>rhs</span><span class=p>.</span><span class=n>size_</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>size_</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>copy</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>ptr_</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>ptr_</span> <span class=o>+</span> <span class=n>size_</span><span class=p>,</span> <span class=n>ptr_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=初始化不是赋值>初始化不是赋值</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NaiveVector</span> <span class=n>w</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>	<span class=c1>// 调用拷贝构造，创建一个新的对象
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NaiveVector</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>w</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>	<span class=c1>// 对 w 的赋值，调用赋值运算符
</span></span></span></code></pre></td></tr></table></div></div><p>这个问题似乎困扰了很多初学者，虽然看起来都使用了 <code>=</code> ，但实际不是一回事。</p><p>实际很容易理解，初始化时 w 什么都没有，自然需要构造，自然调用的是拷贝构造函数。</p><p>而在赋值时，w 已经是初始化结束的，或者被使用过的，内部已经存在数据了，可能需要对其进行其他处理，故自然不能调用拷贝构造，需要使用赋值运算符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>NaiveVector</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>w</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>编译器默认生成的赋值运算符也是单纯的拷贝赋值所有数据成员，所以我们也需要实现他。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NaiveVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span><span class=p>()</span> <span class=o>:</span> <span class=n>ptr_</span><span class=p>(</span><span class=k>nullptr</span><span class=p>),</span> <span class=n>size_</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>NaiveVector</span><span class=p>()</span> <span class=p>{</span><span class=k>delete</span><span class=p>[]</span> <span class=n>ptr_</span><span class=p>;}</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span><span class=p>(</span><span class=k>const</span> <span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>NaiveVector</span> <span class=n>copy</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>	<span class=c1>// copy and swap，我们需要实现 swap
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>记住：</p><ul><li>当你提供了析构函数时，大概率也需要提供一个拷贝构造函数 和 一个拷贝赋值运算符</li><li><strong>析构函数的职责是防止资源泄漏，拷贝构造函数的职责是防止 <code>double free</code></strong></li><li>这些规则适用于内存等任何你需要手动管理的资源</li></ul><hr><h3 id=the-rule-of-three>The Rule of Three</h3><p>如果你的类直接管理某些资源（见上文），你需要<strong>提供以下三个成员函数</strong>：</p><ul><li><p><strong>析构函数</strong>，用于<strong>释放</strong>资源</p></li><li><p><strong>拷贝构造函数</strong>，用于<strong>拷贝</strong>资源，同时防止 double free</p></li><li><p><strong>拷贝赋值运算符</strong>，<strong>释放</strong> left-hand 资源，并<strong>拷贝</strong> right-hand 资源</p></li></ul><p>推荐使用 <code>copy-and-swap</code> 技巧来实现赋值。</p><p>原因在于，手动实现不能很好的处理嵌套结构中 <em>self-assignment</em> 的情况。[关于自赋值的检测 <a class=link href=https://zhuanlan.zhihu.com/p/673069657 target=_blank rel=noopener>重载operator=要不要检查自赋值？ - mq白</a>]</p><p>使用 <code>copy-and-swap</code> 可以防止你在自赋值一些复杂的嵌套数据结构时爆炸。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=n>NaiveVector</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span> <span class=nf>copy</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>copy</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>先对 rhs 做个拷贝，这样不管是任何的引用关系还是所有权，都不会对我们造成影响。</p><h2 id=raii-与异常安全>RAII 与异常安全</h2><p>虽然 RAII 是关于初始化的，但实际上他真正的意思是 <em><strong>cleanup</strong></em></p><p>也许应该 RAII 应该称作：Resource Freeing Is Destruction</p><p>析构函数帮助我们的程序在异常状态下也能稳定运行。</p><ul><li>C++支持 try/catch 以及 throw</li><li>异常抛出时，runtime 在调用者栈中查找一个与异常类型对应的 catch，假设他找到的话……</li><li>runtime 进行 <em><strong>stack unwinding</strong></em>。对于每个 throw 和 catch 之间的 local scope 中的变量调用析构函数</li><li>为避免泄漏，<strong>请在析构函数中清理你的代码</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=o>*</span> <span class=n>arr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;BAD RAII Example&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>arr</span><span class=p>;</span>	<span class=c1>// 无法执行的 cleanup
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span> <span class=n>ex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Exception: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ex</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里调用了 new，如果发生了异常，那么无法执行 delete，无法 cleanup，就会造成内存泄漏。</p><p>我们要做的是写一个自己的 RAII 类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>RAIIPtr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>ptr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>RAIIPtr</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>p</span><span class=p>)</span> <span class=o>:</span> <span class=n>ptr_</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>RAIIPtr</span><span class=p>()</span> <span class=p>{</span><span class=k>delete</span><span class=p>[]</span> <span class=n>ptr_</span><span class=p>;}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RAIIPtr</span> <span class=n>arr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>runtime_error</span><span class=p>(</span><span class=s>&#34;example&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span><span class=o>&amp;</span> <span class=n>ex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Exception: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ex</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>把 delete 放入析构函数，发生异常时进行 stack unwinding 会析构 RAIIPtr，此时会正确调用。</p><p>但实际上 <code>RAIIPtr</code> 还是很危险，因为他有默认拷贝构造函数（没有遵循 Rule of Three）。</p><p>如果我们不想让 RAIIPtr 允许被拷贝，那么可以将其拷贝构造函数、拷贝赋值运算符都声明为 <code>= delete</code> 。</p><h2 id=the-rule-of-zero>The Rule of Zero</h2><p><strong>如果你的类没有 <em>直接</em> 管理某些资源，只是单纯用了一些库组件，例如 <code>std::vector</code> 或者 <code>std::string</code> ，那么你 <em>不</em> 应该写特殊成员函数， <em>直接声明他们为 <code>default</code>。</em></strong></p><p>让编译器自动生成那些函数即可。</p><p>你也可以自己写 swap，也许会提高一些性能（编译器会ADL查找非成员函数的 swap）</p><p>(这里的意思是针对那 5 个成员函数，而不是针对构造函数，你可以实现一些构造函数，不会打破 rule of zero.)</p><h2 id=尽可能多选择-rule-of-zero>尽可能多选择 Rule of Zero</h2><p>以下两种值语义的类都是 well-designed :</p><ul><li><p><em><strong>Business-logic classes</strong></em>，不管理任何资源，遵循 Rule of Zero</p><p>他们把管理资源的工作 <strong>委托</strong> 给数据成员，例如类中使用 std::string, std::vector, std::unique_ptr 等。这些类默认都遵守 RAII。</p></li><li><p><em><strong>Resource-management classes</strong></em>(small, single-purpose), 遵循 Rule of Three</p><p>构造函数获取资源，析构函数释放资源，在赋值运算符中 <code>copy-and-swap</code> 以及其他特殊成员函数</p></li></ul><h2 id=the-rule-of-five>The Rule of Five</h2><p>在 C++11 之后，有了移动语义加持，我们引入了 The rule of five.</p><p>如果你的类直接管理某些资源（例如 new 出的指针），那么你需要<strong>手写五个特殊成员函数</strong>来确保正确的行为：</p><ul><li><strong>析构函数</strong> 释放资源</li><li><strong>拷贝构造函数</strong> 拷贝资源</li><li><strong>移动构造函数</strong> 转义资源的所有权</li><li><strong>拷贝赋值运算符</strong> 释放 left-hand 资源，拷贝 right-hand 资源</li><li><strong>移动赋值运算符</strong> 释放 left-hand 资源，将 right-hand 的资源所有权转移</li></ul><blockquote><p>根本原因是用户定义（或者声明为 =default, = delete）的构造函数、拷贝构造函数、拷贝赋值运算符，都会阻止移动构造和移动赋值的生成，所以支持移动语义的类都需要你手动写出所有的特殊成员函数。</p><p>所有权，ownership，C++11之后 std::unique_ptr 等即代表独占所有权，配合移动语义，是一个较为重要的概念。但也有人不太喜欢这种说法。</p><p>隔壁 rust 好像很喜欢。</p></blockquote><p>赋值运算符很容易出错，所以活用 <code>copy-and-swap</code></p><p>那么移动赋值运算符怎么写 <code>copy-and-swap</code> 呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>NaiveVector</span><span class=o>&amp;</span> <span class=n>NaiveVector</span><span class=o>::</span><span class=n>opeartor</span><span class=o>=</span><span class=p>(</span><span class=n>NaiveVector</span><span class=o>&amp;&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NaiveVector</span> <span class=nf>copy</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>rhs</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>copy</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=the-rule-of-fourand-a-half>The Rule of Four(and a half)</h2><h3 id=by-value-的赋值运算符>By-value 的赋值运算符？</h3><p>虽然看似传值可以行为正确，但 STL 总是分开写移动和复制，所以你也应该将他们分开。更不能把 operator= 写成模板函数。</p><h3 id=the-rule-of-four-and-a-half>The Rule of Four (and a half)</h3><p>如果你的类直接管理某些资源（例如 new 出的指针），那么你需要<strong>手写四个特殊成员函数</strong>来确保正确的行为</p><ul><li><strong>析构函数</strong> 释放资源</li><li><strong>拷贝构造函数</strong> 拷贝资源</li><li><strong>移动构造函数</strong> 转义资源的所有权</li><li><strong>By-value</strong> 的赋值运算符，释放 left-hand 资源，转移 right-hand 资源的所有权</li></ul><p>1/2 - （非成员 swap 函数，理想情况下还要有一个成员函数版本）</p><h2 id=copy-and-swap>copy-and-swap</h2><p>你需要编写一个 swap 函数才能实现 copy-and-swap，不然要么编译错误，要么使用 <code>std::swap</code></p><p>那 <code>std::swap</code> 干了什么？</p><p>调用移动构造，调用移动赋值，再调用一次移动赋值。</p><p>如果你的赋值运算符的实现使用了 swap，然后还调用了 std::swap，然后 std::swap 又调用你的移动赋值运算符。恭喜你。</p><p>所以强烈推荐你，如果使用 copy-and-swap，那么就自己实现一个 <code>swap</code> 函数。</p><h2 id=不再-naive-的-vector>不再 Naive 的 vector</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>NaiveVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>ptr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>Vec</span><span class=p>(</span><span class=k>const</span> <span class=n>Vec</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ptr_</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>rhs</span><span class=p>.</span><span class=n>size_</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>size_</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>copy</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>ptr_</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>ptr_</span> <span class=o>+</span> <span class=n>size_</span><span class=p>,</span> <span class=n>ptr_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Vec</span><span class=p>(</span><span class=n>Vec</span><span class=o>&amp;&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ptr_</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>exchange</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>ptr_</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>exchange</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>size_</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 两个参数的 swap，让你的类 std::swappable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>friend</span> <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>Vec</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>Vec</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Vec</span><span class=p>()</span> <span class=p>{</span> <span class=k>delete</span><span class=p>[]</span> <span class=n>ptr_</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Vec</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Vec</span><span class=o>&amp;</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vec</span> <span class=nf>copy</span><span class=p>(</span><span class=n>vec</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>Vec</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Vec</span><span class=o>&amp;&amp;</span> <span class=n>vec</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vec</span> <span class=nf>copy</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>vec</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>copy</span><span class=p>.</span><span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=n>Vec</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>ptr_</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>ptr_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>size_</span><span class=p>,</span> <span class=n>rhs</span><span class=p>.</span><span class=n>size_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>std::exchange，以 new_value 替换 obj 的值，并返回 obj 的旧值。</p></blockquote><p>注意两个参数的 swap，这里使用了叫 &ldquo;hidden friend idiom&rdquo;。</p><p>让两个参数的 swap 被 friend 标记，这样编译器就知道他不是成员函数（不是成员函数所以需要两个参数），这个 swap 支持 ADL 查找。这里他唯一做的就是调用一下成员函数 swap。</p><h2 id=管理资源类的例子>管理资源类的例子</h2><h3 id=stdunique_ptr>std::unique_ptr</h3><p>以 <code>std::unique_ptr</code> 为例，它管理了堆内存的裸指针。</p><ul><li><strong>构造函数</strong>释放资源<ul><li>对裸指针调用 delete</li></ul></li><li><strong>拷贝构造函数</strong>复制资源<ul><li>显然不应该复制，它独占了这个资源的所有权。故 =delete</li></ul></li><li><strong>移动构造函数</strong>转移资源所有权<ul><li>转移裸指针，确保 rhs 清空</li></ul></li><li><strong>拷贝赋值运算符</strong>释放 left-hand 资源，并复制 right-hand 资源<ul><li>同拷贝构造</li></ul></li><li><strong>移动赋值运算符</strong>释放 left-hand 资源，并转移 right-hand 资源所有权<ul><li>对 left-hand 调用 delete，转移 right-hand 资源并情况</li></ul></li></ul><h3 id=stdshared_ptr>std::shared_ptr</h3><p>以 <code>std::shared_ptr</code> 为例，它管理的是引用计数。</p><ul><li><strong>构造函数</strong>释放资源<ul><li>减少引用计数（清理资源，如果引用计数归零）</li></ul></li><li><strong>拷贝构造函数</strong>复制资源<ul><li>增加引用计数</li></ul></li><li><strong>移动构造函数</strong>转移资源所有权<ul><li>保持引用计数不变，释放（disengages）右侧</li></ul></li><li><strong>拷贝赋值运算符</strong>释放 left-hand 资源，并复制 right-hand 资源<ul><li>减少 left-hand 引用计数，增加 right-hand 引用计数</li></ul></li><li><strong>移动赋值运算符</strong>释放 left-hand 资源，并转移 right-hand 资源所有权<ul><li>减少引用计数，释放（disengages）右侧</li></ul></li></ul><h2 id=盗取暗示了空状态>“盗取”暗示了“空”状态</h2><p>每个例子的移动操作，都释放了右侧的资源，也就是清空右侧状态。</p><p>如果你忘了，那么可能会 double-free</p><p>如果你忘记 destroy 右侧的对象，那么他可能就会处于空状态。</p><p>你可以只做 copy 和 destroy，如果你的对象复制开销不大的话。</p><p>当然 RAII 也可以 <em>只</em> 用于 destroy，单纯 =delete 你的复制和移动操作，就像 std::lock_guard</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Dec 23, 2023 00:00 UTC</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Roses</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>