<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。"><title>智能指针</title>
<link rel=canonical href=https://rossqaq.github.io/article/cppcon-2019-smart-pointers/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="智能指针"><meta property='og:description' content="对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。"><meta property='og:url' content='https://rossqaq.github.io/article/cppcon-2019-smart-pointers/'><meta property='og:site_name' content='Roses'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2023-12-25T00:00:00+00:00'><meta property='article:modified_time' content='2023-12-25T00:00:00+00:00'><meta property='og:image' content='https://rossqaq.github.io/article/cppcon-2019-smart-pointers/cppcon2019-cover.png'><meta name=twitter:title content="智能指针"><meta name=twitter:description content="对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://rossqaq.github.io/article/cppcon-2019-smart-pointers/cppcon2019-cover.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu57fe4ea25b3b752b8c24bca0d657f08c_427356_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>♉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Roses</a></h1><h2 class=site-description>有限的时间，无尽的痛苦。</h2></div></header><ol class=menu-social><li><a href=https://space.bilibili.com/3078464 target=_blank title=Bilibili rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-bilibili" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z"/><path d="M8 3l2 3"/><path d="M16 3l-2 3"/><path d="M9 13v-2"/><path d="M15 11v2"/></svg></a></li><li><a href=https://github.com/RossQAQ target=_blank title=Github rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href='https://music.163.com/playlist?id=109571638&amp;userid=93740300' target=_blank title=网易云音乐 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-netease-music" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 4c-2.93 1.346-5 5.046-5 8.492C4 17 8 20 12 20s8-3 8-7c0-3.513-3.5-5.513-6-5.513S9 9 9 12c0 2 1.5 3 3 3s3-1 3-3c0-3.513-2-4.508-2-6.515.0-3.504 3.5-2.603 4-1.502"/></svg></a></li><li><a href=mailto:rossqaq@outlook.com target=_blank title=邮件 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友情链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#智能指针发展历史>智能指针发展历史</a></li><li><a href=#stdunique_ptr-独占所有权>std::unique_ptr ：独占所有权</a></li><li><a href=#使用智能指针时的推荐做法>使用智能指针时的推荐做法</a></li><li><a href=#stdshared_ptr共享所有权>std::shared_ptr：共享所有权</a><ol><li><a href=#控制块>控制块</a></li><li><a href=#类的布局>类的布局</a></li><li><a href=#shared_ptr-的-aliasing-construct>shared_ptr 的 aliasing construct</a></li></ol></li><li><a href=#优先选择-make_uniquemake_shared>优先选择 make_unique()/make_shared()</a></li><li><a href=#stdweak_ptr解决-shared_ptr-的悬垂>std::weak_ptr：解决 shared_ptr 的悬垂</a><ol><li><a href=#你并不能解引用-weak_ptr>你并不能解引用 weak_ptr</a></li></ol></li><li><a href=#通过-raw-ptr-获得-shared_ptr>通过 raw ptr 获得 shared_ptr</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/article/cppcon-2019-smart-pointers/><img src=/article/cppcon-2019-smart-pointers/cppcon2019-cover_hu93d2f8befaf9243db44dc194e94262d5_58262_800x0_resize_box_3.png srcset="/article/cppcon-2019-smart-pointers/cppcon2019-cover_hu93d2f8befaf9243db44dc194e94262d5_58262_800x0_resize_box_3.png 800w, /article/cppcon-2019-smart-pointers/cppcon2019-cover_hu93d2f8befaf9243db44dc194e94262d5_58262_1600x0_resize_box_3.png 1600w" width=800 height=339 loading=lazy alt="Featured image of post 智能指针"></a></div><div class=article-details><header class=article-category><a href=/categories/cppcon/ style=background-color:#2a9d8f;color:#fff>CppCon
</a><a href=/categories/finished/ style=background-color:#2a9d8f;color:#fff>施工完毕</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/article/cppcon-2019-smart-pointers/>智能指针</a></h2><h3 class=article-subtitle>对 CppCon 2019, Arthur O'Dwyer 演讲的翻译与总结。</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 25, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 5 分钟</time></div></footer></div></header><section class=article-content><p><a class=link href="https://www.youtube.com/watch?v=xGDLkt-jBJ4" target=_blank rel=noopener>CppCon 2019: Arthur O&rsquo;Dwyer “Back to Basics: Smart Pointers”</a></p><p>C++11 的面试圣经 —— 智能指针</p><p>我发现这个人讲的还是不错的，就是语速太快……不过好在他的 lecture 都有官方字母。</p><h2 id=智能指针发展历史>智能指针发展历史</h2><p><code>auto_ptr</code> : C++98 的遗老，C++17被移除</p><p><code>unique_ptr</code>: C++11. 用来替代 auto_ptr，C++14 加入了 <code>std::make_unique()</code></p><p><code>shared_ptr</code>: C++11. 引用计数，支持<code>std::make_shared()</code> 。C++17 加入了 <code>std::shared_ptr&lt;T[]></code></p><p><code>weak_ptr</code> : C++11. 弱引用。</p><p>C++20 : <code>std::make_shared&lt;T[]></code></p><h2 id=stdunique_ptr-独占所有权>std::unique_ptr ：独占所有权</h2><p><code>std::unique_ptr</code> 可以自动替你管理资源。</p><p>原始指针是可以拷贝的，那么如果我拷贝了原始指针，那么谁来清理资源呢？这个不太好说。</p><p><code>std::unique_ptr</code> 是 move-only，它的移动构造会将原来的指针置为 nullptr。</p><p>只有一个指针指向资源，<code>std::unique_ptr</code> 会自动帮你管理资源。</p><p>此外，<code>std::unique_ptr</code> 有一个对 T[] 的特化：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>unique_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=p>[]</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span><span class=o>*</span> <span class=n>p_</span> <span class=p>{</span><span class=k>nullptr</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>unique_ptr</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=p>[]</span> <span class=n>p_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p><code>std::unique_ptr</code> 还有一个模板参数：Deleter。你可以显式的传入一个 deleter。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Deleter</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>default_delete</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>unique_ptr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span><span class=o>*</span> <span class=n>p_</span><span class=p>{</span><span class=k>nullptr</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>Deleter</span> <span class=n>d_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>unique_ptr</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p_</span><span class=p>)</span> <span class=n>d_</span><span class=p>(</span><span class=n>p_</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>default_delete</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>opeartor</span><span class=p>()(</span><span class=n>T</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>假设我们使用一个 FILE*</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FileCloser</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>operator</span><span class=p>()(</span><span class=n>FILE</span><span class=o>*</span> <span class=n>fp</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>assert</span><span class=p>(</span><span class=n>fp</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>fclose</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=s>&#34;input.txt&#34;</span><span class=p>,</span> <span class=sc>&#39;r&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>FILE</span><span class=p>,</span> <span class=n>FileCloser</span><span class=o>&gt;</span> <span class=n>uptr</span><span class=p>(</span><span class=n>fp</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>这样的话可以更加异常安全，而且可以完美适配 C API。</p><p>如果你使用类似于 OpenSSL 这样的 C API 的话，就可以使用这个用法。unique_ptr 可以作为 low-level (C API), non-RAII, raw resource 和 高级 API 间的粘合剂。</p><h2 id=使用智能指针时的推荐做法>使用智能指针时的推荐做法</h2><ul><li>像对待裸指针一样对待智能指针<ul><li>pass by value</li><li>return by value（当然）</li><li>对指针传引用太异味了，自然对智能指针也是</li></ul></li><li>如果一个函数接受 <code>unique_ptr</code> by value，那么意味着<strong>所有权的转移</strong></li><li>智能指针通常作为实现细节以及胶水<ul><li>在接口中暴露 unique_ptr/shared_ptr 有点 code smell，你应该把他们放在类里。</li></ul></li></ul><h2 id=stdshared_ptr共享所有权>std::shared_ptr：共享所有权</h2><h3 id=控制块>控制块</h3><p>std::shared_ptr 代表<strong>共享所有权</strong>，使用 <em><strong>引用计数</strong></em> 实现。计数归零就会析构对象。引用计数可以使用一个 <code>std::atomic&lt;int></code></p><p>对于一个 std::shared_ptr ，一般有两个成员，一个指向被管理对象的指针，另外一个指向<strong>控制块</strong>（control block）的指针。</p><p>控制块包含：引用计数、弱引用计数、自定义 deleter、指向管理对象的指针。</p><p><strong>每个被管理的对象拥有一个控制块。</strong></p><p>拷贝 shared_ptr，会拷贝两个指针，然后引用计数 +1。如果销毁 shared_ptr ，引用计数 -1</p><p>shared_ptr 通过控制块参与所有权的管理。</p><p>那么为什么控制块要有一个指向控制对象的指针呢？</p><h3 id=类的布局>类的布局</h3><p>考虑以下的结构：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Fruit</span> <span class=p>{</span><span class=kt>int</span> <span class=n>juice</span><span class=p>;};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Vegetable</span> <span class=p>{</span><span class=kt>int</span> <span class=n>fiber</span><span class=p>;};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Apple</span> <span class=o>:</span> <span class=n>Fruit</span> <span class=p>{</span><span class=kt>int</span> <span class=n>red</span><span class=p>;};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Tomato</span> <span class=o>:</span> <span class=n>Fruit</span><span class=p>,</span> <span class=n>Vegetable</span> <span class=p>{</span><span class=kt>int</span> <span class=n>sauce</span><span class=p>;};</span>
</span></span></code></pre></td></tr></table></div></div><p>Apple 继承 Fruit，实际上的布局大概是 |juice|red| 这样。</p><p>类似的，Tomato 大概是 |juice|fiber|sauce|</p><p>Apple is a Fruit，也就是说我有一个指向 Apple 的指针的同时也代表了指向 Fruit，先是 Fruit 的成员之后才是 Apple 的成员。</p><p>Tomato 类似。</p><p>就是说，如果我有一个 <code>std::shared_ptr&lt;Fruit></code> 和一个 <code>std::shared_ptr&lt;Vegetable></code>，他们都指向了 <code>Tomato</code>。指向 vegetable 的那个指针会有一些偏移。并没有指向直接需要管理的对象。</p><p>所以控制块中需要一个指针来决定对谁来执行 delete，在这里就是保存一个 tomato 对象的指针。</p><h3 id=shared_ptr-的-aliasing-construct>shared_ptr 的 aliasing construct</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>Vec</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>elts</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Vec</span><span class=o>&gt;</span> <span class=n>pvec</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Vec</span><span class=o>&gt;</span><span class=p>(</span><span class=n>elts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>pvec</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=o>*</span><span class=n>pvec</span><span class=p>)[</span><span class=mi>2</span><span class=p>]);</span>	<span class=c1>// 与 pvec 共享所有权，但指向 &amp;(*pvec)[2]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ptr</span> <span class=o>=</span> <span class=n>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=o>-</span><span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>ptr</span><span class=p>.</span><span class=n>get</span><span class=p>()[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在以上的代码中，shared_ptr 中指向对象的成员指针指向的是 vec[2]，但控制块中的指针指向的是 vector</p><p>最后一个 shared_ptr 销毁时就会销毁 vector</p><h2 id=优先选择-make_uniquemake_shared>优先选择 make_unique()/make_shared()</h2><p>现代 C++ 的目的之一就是，没有 new/delete 出现，且只调用 new 看起来也很难受。</p><p>比如下面这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>w</span><span class=p>(</span><span class=k>new</span> <span class=n>Widget</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>use</span><span class=p>(</span><span class=n>w</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>也就是说，如果没调用 delete，那也应该尽量避免 new。标准库所以提供了 make_foo()</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>w</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>use</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>make_shared 也可以被优化，可以少一次内存分配，现在的库基本都能做到。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>make_shared</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span><span class=o>*</span> <span class=n>raw_ptr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ControlBlockAnd</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>From</span><span class=p>(</span><span class=n>raw_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>总之：</p><ul><li>多使用 make_shared/make_unique 避免 new</li><li>你不 new 就不会内存泄漏</li><li>make_shared 可以优化</li></ul><p>顺便，unique_ptr 可以隐式转换为 shared_ptr</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>sptr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=stdweak_ptr解决-shared_ptr-的悬垂>std::weak_ptr：解决 shared_ptr 的悬垂</h2><p><code>weak_ptr</code> 在内存上看和 <code>shared_ptr</code> 差不多，都有一个指向管理对象的指针和一个指向控制块的指针。</p><p>区别在于，<strong>如果你拷贝 <code>weak_ptr</code> ，那么它会增加 <em>弱引用计数</em></strong> 。</p><p>如果引用计数归零，那么对象会被销毁，而此时如果弱引用计数不为0，就会出现 <code>weak_ptr</code> 悬垂。<code>shared_ptr</code> 知道控制块还有 <code>weak_ptr</code> 在使用，所以也不会销毁控制块。</p><h3 id=你并不能解引用-weak_ptr>你并不能解引用 weak_ptr</h3><ul><li><code>weak_ptr</code> 并不是指针，它只是你在未来构造 <code>shared_ptr</code> 时的门票。</li><li>你可以显式类型转换，或者调用 weak_ptr.lock()，虽然不会 lock 任何东西，它只是会返回一个 shared_ptr（如果对象没有被销毁的话）</li><li>如果想 get a ticket，那么只能使用显式类型转换</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>recommended</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>weak_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>wptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// std::shared_ptr&lt;T&gt; sptr{wptr}; 不要这么做
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>sptr</span> <span class=o>=</span> <span class=n>wptr</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sptr</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>use</span><span class=p>(</span><span class=n>sptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其实可以在 if 语句内直接声明（这也是 if 内声明有用的几个情景之一）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>sptr</span> <span class=o>=</span> <span class=n>wptr</span><span class=p>.</span><span class=n>lock</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>use</span><span class=p>(</span><span class=n>sptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>顺便一提，另一个情景是 RTTI</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>RedWidget</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>RedWidget</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>widgetpr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>use_red_widget</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=通过-raw-ptr-获得-shared_ptr>通过 raw ptr 获得 shared_ptr</h2><p>我们之前说 weak_ptr 是 ticket for shared_ptr，那么如果你只有一个裸指针怎么办？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>weak_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>wptr_</span> <span class=o>=</span> <span class=o>???</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>shared_from_this</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>wptr</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>自然我们不会每次都自己写，所以我们把 weak_ptr 放到基类，叫做 <code>std::enable_shared_from_this</code>，他的作用就是提供 <code>shared_from_this()</code> 成员函数。</p><p>这个你自己是实现不了的，因为它跟 shared_ptr 的构造函数有关联。</p><p>它使用的是 CRTP 模式。</p><ul><li>trick 的是 Widget 的 <code>shared_from_this()</code> 成员函数返回的是 <code>shared_ptr&lt;Widget></code>。我们通过某种方式，让基类知道了子类的名字。方法是我们让 base 类是一个模板，模版参数是子类的名字。这样的话，<code>Widget</code> 继承自 <code>std::enable_shared_from_this&lt;Widget></code>，这样就可以了。</li></ul></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Dec 25, 2023 00:00 UTC</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Roses</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>