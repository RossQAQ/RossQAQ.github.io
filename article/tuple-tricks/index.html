<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="除了我之外人尽皆知的 std::tuple 魔法"><title>普通的 std::tuple 技巧</title>
<link rel=canonical href=https://rossqaq.github.io/article/tuple-tricks/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="普通的 std::tuple 技巧"><meta property='og:description' content="除了我之外人尽皆知的 std::tuple 魔法"><meta property='og:url' content='https://rossqaq.github.io/article/tuple-tricks/'><meta property='og:site_name' content='Roses'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2024-03-24T00:00:00+00:00'><meta property='article:modified_time' content='2024-03-24T00:00:00+00:00'><meta name=twitter:title content="普通的 std::tuple 技巧"><meta name=twitter:description content="除了我之外人尽皆知的 std::tuple 魔法"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu57fe4ea25b3b752b8c24bca0d657f08c_427356_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>♉</span></figure><div class=site-meta><h1 class=site-name><a href=/>Roses</a></h1><h2 class=site-description>有限的时间，无尽的痛苦。</h2></div></header><ol class=menu-social><li><a href=https://space.bilibili.com/3078464 target=_blank title=Bilibili rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-bilibili" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z"/><path d="M8 3l2 3"/><path d="M16 3l-2 3"/><path d="M9 13v-2"/><path d="M15 11v2"/></svg></a></li><li><a href=https://github.com/RossQAQ target=_blank title=Github rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href='https://music.163.com/playlist?id=109571638&amp;userid=93740300' target=_blank title=网易云音乐 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-netease-music" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 4c-2.93 1.346-5 5.046-5 8.492C4 17 8 20 12 20s8-3 8-7c0-3.513-3.5-5.513-6-5.513S9 9 9 12c0 2 1.5 3 3 3s3-1 3-3c0-3.513-2-4.508-2-6.515.0-3.504 3.5-2.603 4-1.502"/></svg></a></li><li><a href=mailto:rossqaq@outlook.com target=_blank title=邮件 rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友情链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#getting-started>Getting Started</a></li><li><a href=#通过-index-sequence-进行选择-1>通过 index sequence 进行选择 1</a></li><li><a href=#通过-index-sequence-进行选择-2>通过 index sequence 进行选择 2</a></li><li><a href=#创建有趣的-index-sequence>创建有趣的 index sequence</a></li><li><a href=#创建更有趣的-index-sequence>创建更有趣的 index sequence</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/techs/ style=background-color:#2a9d8f;color:#fff>技术
</a><a href=/categories/cppnotes/ style=background-color:#2a9d8f;color:#fff>C++ 随记
</a><a href=/categories/unfinished/ style=background-color:#2a9d8f;color:#fff>施工中</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/article/tuple-tricks/>普通的 std::tuple 技巧</a></h2><h3 class=article-subtitle>除了我之外人尽皆知的 std::tuple 魔法</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 24, 2024</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 6 分钟</time></div></footer></div></header><section class=article-content><p>本文来自 Raymond Chen 的系列博客</p><p>[Mundane std::tuple tricks: Getting started](<a class=link href="https://devblogs.microsoft.com/oldnewthing/20200622-00/?p=103900" target=_blank rel=noopener>Mundane std::tuple tricks: Getting started - The Old New Thing (microsoft.com)</a>)</p><p><a class=link href="https://devblogs.microsoft.com/oldnewthing/20200623-00/?p=103901" target=_blank rel=noopener>Mundane std::tuple tricks: Selecting via an index sequence</a></p><p><a class=link href="https://devblogs.microsoft.com/oldnewthing/20200624-00/?p=103902" target=_blank rel=noopener>Mundane std::tuple tricks: Selecting via an index sequence, part 2</a></p><p><a class=link href="https://devblogs.microsoft.com/oldnewthing/20200625-00/?p=103903" target=_blank rel=noopener>Mundane std::tuple tricks: Creating interesting index sequences</a></p><p><a class=link href="https://devblogs.microsoft.com/oldnewthing/20200626-00/?p=103904" target=_blank rel=noopener>Mundane std::tuple tricks: Creating more interesting index sequences</a></p><p><a class=link href="https://devblogs.microsoft.com/oldnewthing/20200629-00/?p=103910" target=_blank rel=noopener>Mundane std::tuple tricks: Finding a type in a tuple</a></p><p><strong>未取得授权，私自翻译，仅用于学习目的，如若侵权联系我删除</strong>。</p><hr><h2 id=getting-started>Getting Started</h2><p>C++ 标准库的 <code>tuple</code> 充满魔法，它可以将一堆类型或者值 grab 到一个单个的单位，并且 C++ 标准库也提供了很多帮助函数来辅助操作。</p><p>例如，<code>std::make_tuple</code> 让你可以从一堆值中构造 tuple，用来解决你捕获参数包之后把它变成可以操作的东西：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>[](</span><span class=k>auto</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>args_tuple</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们学习过，<code>std::tuple_element_t</code> 可以让你从 tuple 中获取单个类型，<code>std::get</code> 可以获取单个值。</p><p>标准库提供 <code>std::tuple_cat</code> 来串联 N 个 tuple 的值，但标准库没有提供串联 N 个 tuple 类型的版本，我们可以自己实现一个：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>tuple_cat_helper</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span><span class=p>...</span> <span class=n>T2</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>tuple_cat_helper</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>...</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>T2</span><span class=p>...</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>...,</span> <span class=n>T2</span><span class=p>...</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>tuple_cat_t</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>tuple_cat_helper</span><span class=o>&lt;</span><span class=n>T1</span><span class=p>,</span> <span class=n>T2</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example is std::tuple&lt;int, char, double&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>example</span> <span class=o>=</span> <span class=n>tuple_cat_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>我们定义了一个特化的模板 <code>tuple_cat_helper</code> 来析取所有的 tuple 类型并且生成新的类型，串联两个 tuple 列表。之后定义了 <code>_t</code> 的版本。</p><p>或者也可以偷懒，让 <code>std::tuple_cat</code> 来做：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>T2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>tuple_cat_t</span> <span class=o>=</span> <span class=k>decltype</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>tuple_cat</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>T1</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>T2</span><span class=o>&gt;</span><span class=p>()));</span>
</span></span></code></pre></td></tr></table></div></div><p>然后为了让他支持多个 Tuple：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Tuples</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>tuple_cat_t</span> <span class=o>=</span> <span class=k>decltype</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>tuple_cat</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>declval</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>()...));</span>
</span></span></code></pre></td></tr></table></div></div><p>写的更少，做的更多。</p><p>标准库中有工具把它们组合在一起，但是没有工具把它们分开。</p><p><strong>Bonus chatter</strong>: I wasn’t quite telling the truth when I said that <code>make_tuple</code> can capture a template parameter pack. We’ll come back to this issue later.</p><h2 id=通过-index-sequence-进行选择-1>通过 index sequence 进行选择 1</h2><p>上一次，我们组合了 tuples。组合他们很简单，但想要分开他们有点难。</p><p><code>std::index_sequence</code> (C++14) 由<strong>标准库提供的类型</strong>，捕获 0 个或更多的非负整数序列，然后把它们转换为一个类型。它是 <code>std::integer_sequnence</code> 的特化。<code>std::integer_sequence</code> 会捕获用户提供的类型的整数序列，而 <code>std::index_sequence</code> 的用户提供类型是 <code>std::size_t</code>。</p><p>tuple 的拆分涉及到包含一个 <code>std::index_sequence</code> 的参数包展开。（译者：原文用的 fold expression，但这里明显不是 C++17 的折叠表达式，应该是说包展开吧。）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 不要这么做，之后会解释：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>select_tuple</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>...</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=n>Ints</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>))...</span> <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>以上这一段是拆分 tuple 的<strong>核心</strong>，我们来解释一下。</p><p>第一个参数是需要操作的 tuple，使用万能引用传入，这样我们就可以对他进行转发了。这会保留右值性（rvalue-ness），这在某些情况比如 tuple 是 move-only 的时候非常好用。（在 both copyable and movable 情况下也有帮助，因为它会选择移动，这样的话开销更小）。</p><p>剩下的参数是 <code>size_t</code> 数值，代表 index_sequence 的 index。</p><p>表达式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=n>Ints</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>))...);</span>
</span></span></code></pre></td></tr></table></div></div><p>是 <code>std::make_tuple</code> 的参数列表。表达式会对每个 <code>Ints</code> 包中的值调用，结果就是生成一系列的参数然后来提取 tuple 中对应索引的值。</p><p>例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>res</span> <span class=o>=</span> <span class=n>select_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=sc>&#39;x&#39;</span><span class=p>,</span> <span class=mf>3.14</span><span class=p>,</span> <span class=sc>&#39;z&#39;</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span><span class=p>{});</span>
</span></span></code></pre></td></tr></table></div></div><p>我们提供了一个 3 个元素的 tuple，并且选择 2, 1, 1, 2 对应索引的元素。表达式会展开为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>)))</span>
</span></span></code></pre></td></tr></table></div></div><p>从 tuple 中提取项 2, 1, 1, 2，然后把它们传递给 <code>make_tuple</code> ，重新把它们组成一个 tuple <code>('z', 3.14, 3.14, 'z')</code>。注意索引 1 和 2 都被提取了多次，0没有被提取；也要注意结果 tuple 的 size 跟使用的索引匹配，而不是原 tuple 的 size。</p><p>注意如果 tuple 里的类型是 movable 类型，那么提取 &lt;2, 1, 1, 2> 会导致它们的项被多次移动。这样的话结果就乱了，所以你通常不应该对一个值提取多次。（虽然并没有阻止这么做）。</p><p>不过我们的 <code>select_tuple</code> 也有缺陷。</p><h2 id=通过-index-sequence-进行选择-2>通过 index sequence 进行选择 2</h2><p>上次我们编写了 <code>select_tuple</code> 函数接收一个 tuple 和一个 index sequence 为参数，并且产生一个新的基于 index sequence 选择元素的 tuple。我们有：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Don&#39;t use this; see discussion.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>select_tuple</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>...</span><span class=o>&gt;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=n>Ints</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>))...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>你如果想使用它的话：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=p>,</span> <span class=kt>float</span><span class=o>&gt;</span> <span class=n>t</span><span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=sc>&#39;x&#39;</span><span class=p>,</span> <span class=mf>2.0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>t2</span> <span class=o>=</span> <span class=n>select_tuple</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=o>&gt;</span><span class=p>{});</span>
</span></span></code></pre></td></tr></table></div></div><p><code>t2</code> 是 <code>std::tuple&lt;int, float>{1, 2.0}</code></p><p>但这个函数有问题。</p><p>提问：<strong>什么时候 <code>std::make_tuple&lt;T>()</code> 返回的不是 <code>std::tuple&lt;T></code> ？</strong></p><div class=table-wrapper><table><thead><tr><th><code>std::make_tuple&lt;T></code></th><th>Produces <code>std::tuple&lt;T></code></th></tr></thead><tbody><tr><td>int</td><td>int</td></tr><tr><td>const int</td><td>int</td></tr><tr><td>int&</td><td>int</td></tr><tr><td>int&&</td><td>int</td></tr><tr><td><code>std::reference_wrapper&lt;int></code></td><td>int&</td></tr><tr><td><code>std::reference_wrapper&lt;const int></code></td><td>int&</td></tr><tr><td><code>std::reference_wrapper&lt;int&></code></td><td>int&</td></tr><tr><td><code>std::reference_wrapper&lt;int&&></code></td><td>int&</td></tr></tbody></table></div><p>答案：<strong>当 <code>T</code> 是可以退化，或者是 <code>reference_wrapper</code> 类型的时候</strong></p><p>退化是一个 C++ 术语，指代的是在<strong>传值给函数时类型发生的变化的行为</strong>：</p><ul><li>引用会退化为底层数值类型</li><li>cv 会被移除</li><li>数组退化为指针</li><li>函数退化为函数指针</li></ul><p>但是 <code>make_tuple</code> 有额外的规则：<strong>如果退化的类型是一个 <code>reference_wrapper</code> ，那么其结果是底层的引用类型</strong>。</p><p>我们并不想发生那样的转换。如果你从 tuple 中选择的类型是个引用，那么你想要结果 tuple 也有相同的引用类型。</p><p>所以不能使用 <code>make_tuple</code>，我们得显式的指明我们要的类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>select_tuple</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>...</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>tuple_element_t</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>,</span> <span class=n>Tuple</span><span class=o>&gt;</span><span class=p>...</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=n>Ints</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>))...);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>或者也可以：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>tuple_element_t</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>,</span> <span class=n>Tuple</span><span class=o>&gt;</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>select_tuple</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>...</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=n>Ints</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>))...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>好了，helper 都有了，我们可以玩更花哨的了。</p><h2 id=创建有趣的-index-sequence>创建有趣的 index sequence</h2><p>C++ 标准库对于操作 index sequences 只给了一个 helper，<code>std::make_integer_sequence</code> 以及它的近亲 <code>std::make_index_sequence</code>，也就是 <code>size_t</code>。</p><p>注意，<code>std::make_index_sequnece</code> 的模板参数是结果 index sequence 的大小，并不是最高那个值。</p><p>即使只有从 0 开始的 index sequences，我们也能干很多有趣的事情。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Tuple</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>remove_last</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>size</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple_size_v</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>indices</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>select_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>),</span> <span class=n>indices</span><span class=p>{});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>remove_last</code> 函数移除 tuple 的最后一个元素并且 return 剩下的。我们通过提取源 tuple 的 size 来做到这一点，让他 -1，然后生成一个新的 index sequence（0~size - 2），元素个数就为 size - 1</p><p>那么，其他的 index sequence 怎么样呢？我们得自己实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>N</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Seq</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>offset_sequence</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>N</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>Ints</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>offset_sequence</span><span class=o>&lt;</span><span class=n>N</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>...</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span> <span class=o>+</span> <span class=n>N</span><span class=p>...</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>N</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Seq</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>offset_sequence_t</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>offset_sequence</span><span class=o>&lt;</span><span class=n>N</span><span class=p>,</span> <span class=n>Sqe</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example = index_sequence&lt;3, 4, 5, 6&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>example</span> <span class=o>=</span> <span class=n>offset_sequence_t</span><span class=o>&lt;</span><span class=mi>3</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=mi>4</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>为了实现 index sequence 的偏移版本，我们生成一个新的 index sequence 它持有的序列是原来的序列 + offset N。魔法发生在参数包展开：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl> <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span> <span class=o>+</span> <span class=n>N</span><span class=p>...</span><span class=o>&gt;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这会取出原 index sequence 的每个数，然后 +N，之后用来重新生成一个新的序列。</p><p>现在我们就可以移除 tuple 的第一个元素了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Tuple</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>remove_first</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>size</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple_size_v</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>indices</span> <span class=o>=</span> <span class=n>offset_sequence_t</span><span class=o>&lt;</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=n>size</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>select_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>),</span> <span class=n>indices</span><span class=p>{});</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>实际上，我们可以移除第 N 个元素</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>N</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Tuple</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>remove_Nth_element</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>size</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple_size_v</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>first</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=n>N</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>rest</span> <span class=o>=</span> <span class=n>offset_sequence</span><span class=o>&lt;</span><span class=n>N</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=n>size</span> <span class=o>-</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple_cat</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    	<span class=n>select_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>),</span> <span class=n>first</span><span class=p>{});</span>
</span></span><span class=line><span class=cl>        <span class=n>select_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>),</span> <span class=n>rest</span><span class=p>{});</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们想要的是提取前 N 个元素，然后跳过第 N 个，之后提取 N + 1 个元素到结尾。</p><p>提取前 N 个很简单：直接选择从 0 ~ N - 1的</p><p>提取剩余的需要一些思考：我们想要 N + 1 开始，知道 size - 1 结束，长度为 (size - 1) - (N + 1) + 1 = size - N - 1. 好了，现在我们生成了长度为 size - N - 1 的整数序列，起始点就是 N + 1.</p><p>我们调用两次 <code>select_tuple</code>，一次获取前半部分，一次获取后半部分，之后用 <code>std::tuple_cat</code> 组合。</p><p>另一种方法是只选择一次，如果这么做的话，我们需要结合两个 index sequences</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Sqe1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Seq2</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>cat_sequence</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>cat_sequence</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints1</span><span class=p>...</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints2</span><span class=p>...</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints1</span><span class=p>...,</span> <span class=n>Ints2</span><span class=p>...</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Seq1</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Seq2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>cat_sequence_t</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>cat_sequence</span><span class=o>&lt;</span><span class=n>Seq1</span><span class=p>,</span> <span class=n>Seq2</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// example = index_sequence&lt;3, 1, 4, 1, 5, 9&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>example</span> <span class=o>=</span> <span class=n>cat_sequence_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>9</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>魔法发生在：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints1</span><span class=p>...,</span> <span class=n>Ints2</span><span class=p>...</span><span class=o>&gt;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>接收两个 sequence 并且把他们挨着组成一个单个的序列。</p><p>我们现在可以这样使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>N</span><span class=p>,</span> <span class=k>typename</span> <span class=n>Tuple</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>remove_Nth_element</span><span class=p>(</span><span class=n>Tuple</span><span class=o>&amp;&amp;</span> <span class=n>tuple</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>size</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>tuple_size_v</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>first</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=n>N</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>rest</span> <span class=o>=</span> <span class=n>offset_sequence_t</span><span class=o>&lt;</span><span class=n>N</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>make_index_sequence</span><span class=o>&lt;</span><span class=n>size</span><span class=o>-</span><span class=n>N</span><span class=o>-</span><span class=mi>1</span><span class=o>&gt;&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>indices</span> <span class=o>=</span> <span class=n>cat_sequence_t</span><span class=o>&lt;</span><span class=n>first</span><span class=p>,</span> <span class=n>rest</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>select_tuple</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Tuple</span><span class=o>&gt;</span><span class=p>(</span><span class=n>tuple</span><span class=p>),</span> <span class=n>indices</span><span class=p>{});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=创建更有趣的-index-sequence>创建更有趣的 index sequence</h2><p>我们可以泛化之前的版本，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>F</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>),</span> <span class=k>typename</span> <span class=n>Seq</span><span class=o>&gt;</span> <span class=k>struct</span> <span class=nc>modify_sequence</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>F</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>),</span> <span class=k>typename</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>...</span> <span class=n>Ints</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>modify_sequence</span><span class=o>&lt;</span><span class=n>F</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>Ints</span><span class=p>...</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>index_sequence</span><span class=o>&lt;</span><span class=n>F</span><span class=p>(</span><span class=n>Ints</span><span class=p>)...</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>F</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span><span class=p>),</span> <span class=k>typename</span> <span class=n>Seq</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>modify_sequence_t</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>modify_sequence</span><span class=o>&lt;</span><span class=n>F</span><span class=p>,</span> <span class=n>Seq</span><span class=o>&gt;::</span><span class=n>type</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>未完待续……</p></blockquote></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Mar 24, 2024 00:00 UTC</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 Roses</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>